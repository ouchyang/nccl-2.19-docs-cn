# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the NCCL(2.19) package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: NCCL(2.19)\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-01 14:00+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/api/comms.rst:3 c48cf055bfac4b1587a2e530b75b1014
msgid "Communicator Creation and Management Functions"
msgstr "通信器创建与管理函数"

#: ../../source/api/comms.rst:5 6d3d0174c8ad4e3aadcb77ffea41c007
msgid "The following functions are public APIs exposed by NCCL to create and manage the collective communication operations."
msgstr "以下函数是NCCL公开的用于创建和管理集合通信操作的公共API。"

#: ../../source/api/comms.rst:8 271187c64cf94660a91841c7047e3343
msgid "ncclGetLastError"
msgstr "ncclGetLastError"

#: ../../source/api/comms.rst:12 af8ebe81b28945358a0c27b28679ac0c
msgid ""
"Returns a human-readable string of the last error that occurred in NCCL. Note: The error is not cleared by calling this "
"function. The *comm* argument is currently unused and can be set to NULL."
msgstr "返回NCCL中最近发生错误的人类可读字符串。注意：调用此函数不会清除错误状态。*comm* 参数当前未使用，可设置为NULL。"

#: ../../source/api/comms.rst:18 38fc410f3b4748feb4778f6b470f16e9
msgid "ncclGetVersion"
msgstr "ncclGetVersion"

#: ../../source/api/comms.rst:22 8b5bc3d0e85b4a468d7085911090d5e7
msgid ""
"The ncclGetVersion function returns the version number of the currently linked NCCL library. The NCCL version number is "
"returned in *version* and encoded as an integer which includes the :c:macro:`NCCL_MAJOR`, :c:macro:`NCCL_MINOR` and "
":c:macro:`NCCL_PATCH` levels. The version number returned will be the same as the :c:macro:`NCCL_VERSION_CODE` defined "
"in *nccl.h*. NCCL version numbers can be compared using the supplied macro; :c:macro:`NCCL_VERSION(MAJOR,MINOR,PATCH)`"
msgstr ""
"`ncclGetVersion` 函数返回当前链接的 NCCL 库版本号。版本号通过 *version* 参数以整数形式返回，该整数编码包含 :c:macro:`NCCL_MAJOR`、:c:macro:`NCCL_MINOR` 和 "
":c:macro:`NCCL_PATCH` 级别。返回的版本号将与 *nccl.h* 中定义的 :c:macro:`NCCL_VERSION_CODE` 一致。NCCL 版本号可通过提供的宏 "
":c:macro:`NCCL_VERSION(MAJOR,MINOR,PATCH)` 进行比较。"

#: ../../source/api/comms.rst:30 c53e5b23e2df4167ae34264bc24d7d55
msgid "ncclGetUniqueId"
msgstr "ncclGetUniqueId"

#: ../../source/api/comms.rst:34 ea305128fb144d2f9f42e09445ec0435
msgid ""
"Generates an Id to be used in ncclCommInitRank. ncclGetUniqueId should be called once when creating a communicator and "
"the Id should be distributed to all ranks in the communicator before calling ncclCommInitRank. *uniqueId* should point "
"to a ncclUniqueId object allocated by the user."
msgstr ""
"生成用于`ncclCommInitRank`的标识符。创建通信器时，`ncclGetUniqueId`应被调用一次，且该标识符需在调用`ncclCommInitRank`前分发给通信器中的所有秩。*uniqueId*应指向用户分配的`"
"ncclUniqueId`对象。"

#: ../../source/api/comms.rst:39 28b083ca49c5453aadf93b36eedee493
msgid "ncclCommInitRank"
msgstr "ncclCommInitRank"

#: ../../source/api/comms.rst:43 1eddf6a6440e4078843c4072208ff515
msgid ""
"Creates a new communicator (multi thread/process version). *rank* must be between 0 and *nranks*-1 and unique within a "
"communicator clique. Each rank is associated to a CUDA device, which has to be set before calling ncclCommInitRank. "
"ncclCommInitRank implicitly synchronizes with other ranks, hence it must be called by different threads/processes or "
"use ncclGroupStart/ncclGroupEnd."
msgstr ""
"创建新的通信器（多线程/多进程版本）。*秩*必须介于0到*总秩数-1*"
"之间，且在通信器集群中保持唯一性。每个秩需关联一个CUDA设备，该设备必须在调用ncclCommInitRank前完成设置。ncclCommInitRank会隐式与其他秩进行同步，因此必须由不同线程/"
"进程调用，或使用ncclGroupStart/ncclGroupEnd进行协同调用。"

#: ../../source/api/comms.rst:51 32dcbd436dc44b8098c1ee06963aea51
msgid "ncclCommInitAll"
msgstr "ncclCommInitAll"

#: ../../source/api/comms.rst:55 525c4d16b6ee4c7695889234fdca1a69
msgid ""
"Creates a clique of communicators (single process version) in a blocking way. This is a convenience function to create "
"a single-process communicator clique. Returns an array of *ndev* newly initialized communicators in *comms*. *comms* "
"should be pre-allocated with size at least ndev*sizeof(:c:type:`ncclComm_t`). *devlist* defines the CUDA devices "
"associated with each rank. If *devlist* is NULL, the first *ndev* CUDA devices are used, in order."
msgstr ""
"以阻塞方式创建通信子集团（单进程版本）。这是一个用于创建单进程通信子集团的便捷函数。在*comms*中返回包含*ndev*个新初始化的通信子的数组。*comms*应预先分配至少ndev*sizeof(:c:type:`ncclComm_t`"
")大小的内存空间。*devlist*定义了与每个秩关联的CUDA设备。若*devlist*为NULL，则默认按顺序使用前*ndev*个CUDA设备。"

#: ../../source/api/comms.rst:63 9f04ad52c1d84e1086b13ce8badaec81
msgid "ncclCommInitRankConfig"
msgstr "ncclCommInitRankConfig"

#: ../../source/api/comms.rst:67 202200d03bb24ac19a0766a1454a2b56
msgid ""
"This function works the same way as *ncclCommInitRank* but accepts a configuration argument of extra attributes for the "
"communicator. If config is passed as NULL, the communicator will have the default behavior, as if ncclCommInitRank was "
"called."
msgstr "此函数与*ncclCommInitRank*功能相同，但支持通过配置参数为通信器设置额外属性。若config参数传递为NULL，通信器将保持默认行为，效果等同于调用ncclCommInitRank。"

#: ../../source/api/comms.rst:71 17f75e7a4ee74314915c1c1d9405db96
msgid "See the :ref:`init-rank-config` section for details on configuration options."
msgstr "请参阅 :ref:`初始化与秩配置` 章节了解配置选项的详细信息。"

#: ../../source/api/comms.rst:74 2f9b305259684e93abd716e7555a3e2e
msgid "ncclCommSplit"
msgstr "ncclCommSplit"

#: ../../source/api/comms.rst:78 54075f4324124835b5ac49703b6356c7
msgid ""
"The *ncclCommSplit* function creates a set of new communicators from an existing one. Ranks which are passed the same "
"*color* value will be part of the same group, and a color must be a non-negative value. If it is passed as "
"*NCCL_SPLIT_NOCOLOR*, it means that the rank will not be part of any group, therefore returning NULL as newcomm. The "
"value of key will determine the rank order, and the smaller key means the smaller rank in new communicator. If keys are "
"equal between ranks, then the rank in the original communicator will be used to order ranks. If the new communicator "
"needs to have a special configuration, it can be passed as *config*, otherwise setting config to NULL will make the new "
"communicator inherit the original communicator's configuration. When split, there should not be any outstanding NCCL "
"opereations on the *comm*. Otherwise, it might cause deadlock."
msgstr ""
"*ncclCommSplit* "
"函数基于现有通信器创建一组新通信器。传入相同*color*值的秩将被划分到同一组中，且color必须为非负值。若传入*NCCL_SPLIT_NOCOLOR*"
"，则表示该秩不会加入任何组，因此会返回NULL作为newcomm。key的数值将决定秩的排序顺序，较小的key值对应新通信器中较小的秩。当不同秩的key值相同时，将依据原始通信器中的秩顺序进行排序。若需为新通信器设置特殊配置，可通过*"
"config*参数传入，否则将config设置为NULL会使新通信器继承原始通信器的配置。执行拆分操作时，原有通信器*comm*上不应存在任何未完成的NCCL操作，否则可能引发死锁。"

#: ../../source/api/comms.rst:91 cf60deb0897b428baefcfb8c40fec0c2
msgid "ncclCommFinalize"
msgstr "ncclCommFinalize"

#: ../../source/api/comms.rst:95 a3b9d7e95e944586b68a8820ed255672
msgid ""
"Finalize a communicator object *comm*. When the communicator is marked as nonblocking, *ncclCommFinalize* is a "
"nonblocking function. Successful return from it will set communicator state as *ncclInProgress* and indicates the "
"communicator is under finalization where all uncompleted operations and the network-related resources are being flushed "
"and freed. Once all NCCL operations are complete, the communicator will transition to the *ncclSuccess* state. Users "
"can query that state with *ncclCommGetAsyncError*."
msgstr ""
"完成通信器对象 *comm* 的最终化。当通信器被标记为非阻塞模式时，*ncclCommFinalize* 是一个非阻塞函数。该函数成功返回会将通信器状态设置为 "
"*ncclInProgress*，表明通信器正处于最终化过程中，所有未完成的操作和网络相关资源正在被刷新和释放。当所有NCCL操作完成后，通信器将转换为 *ncclSuccess* 状态。用户可通过 "
"*ncclCommGetAsyncError* 查询该状态。"

#: ../../source/api/comms.rst:103 16b12282134b4382b303cf9f73626552
msgid "ncclCommDestroy"
msgstr "ncclCommDestroy"

#: ../../source/api/comms.rst:107 fa1fe5c911c147e790f0d9619ad06c57
msgid ""
"Destroy a communicator object *comm*. *ncclCommDestroy* only frees the local resources that are allocated to the "
"communicator object *comm* if *ncclCommFinalize* was previously called on the communicator; otherwise, "
"*ncclCommDestroy* will call ncclCommFinalize internally. If *ncclCommFinalize* is called by users, users should "
"guarantee that the state of the communicator become *ncclSuccess* before calling *ncclCommDestroy*. In all cases, the "
"communicators should no longer be accessed after ncclCommDestroy returns. It is recommended that user call "
"*ncclCommFinalize* and then *ncclCommDestroy*."
msgstr ""
"销毁通信器对象 *comm*。仅当先前已对通信器调用过 *ncclCommFinalize* 时，*ncclCommDestroy* 才会释放分配给通信器对象 *comm* 的本地资源；否则 *ncclCommDestroy* "
"将在内部调用 ncclCommFinalize。若用户主动调用 *ncclCommFinalize*，则需确保通信器状态变为 *ncclSuccess* 后再调用 *ncclCommDestroy*。无论何种情况，通信器在 "
"ncclCommDestroy 返回后均不可再被访问。建议用户先调用 *ncclCommFinalize*，再调用 *ncclCommDestroy*。"

#: ../../source/api/comms.rst:116 a66c9caf88d448aaa5d6d40bd2075c0b
msgid "ncclCommAbort"
msgstr "ncclCommAbort"

#: ../../source/api/comms.rst:120 f50fb86c31b441378d5150601e9c45ec
msgid ""
"Frees resources that are allocated to a communicator object *comm*. Will abort any uncompleted operations before "
"destroying the communicator."
msgstr "释放分配给通信器对象 *comm* 的资源。在销毁通信器之前将中止所有未完成的操作。"

#: ../../source/api/comms.rst:124 4e1a87ebc4a544e9a92f03d40f1843b1
msgid "ncclCommGetAsyncError"
msgstr "ncclCommGetAsyncError"

#: ../../source/api/comms.rst:128 7ab56763128a41a8bfa404e45f51984d
msgid ""
"Queries the progress and potential errors of asynchronous NCCL operations. Operations which do not require a stream "
"argument (e.g. ncclCommFinalize) can be considered complete as soon as the function returns *ncclSuccess*; operations "
"with a stream argument (e.g. ncclAllReduce) will return *ncclSuccess* as soon as the operation is posted on the stream "
"but may also report errors through ncclCommGetAsyncError() until they are completed. If return code of any NCCL "
"functions is *ncclInProgress*, it means the operation is in the process of being enqueued in the background, and users "
"must query the states of the communicators until the all states become *ncclSuccess* before calling next NCCL function. "
"Before the states change into *ncclSuccess*, users are not allowed to issue CUDA kernel to the streams being used by "
"NCCL. If there has been an error on the communicator, user should destroy the communicator with "
":c:func:`ncclCommAbort`. If an error occurs on the communicator, nothing can be assumed about the completion or "
"correctness of operations enqueued on that communicator."
msgstr ""
"查询异步NCCL操作的进度与潜在错误。无需流参数的操作（如ncclCommFinalize）在函数返回*ncclSuccess*时即可视为完成；需要流参数的操作（如ncclAllReduce）会在操作被发布到流上后立即返回*"
"ncclSuccess*，但在操作完成前仍可能通过ncclCommGetAsyncError()报告错误。若任何NCCL函数返回码为*ncclInProgress*，表示操作正在后台入队过程中，用户必须持续查询通信器的状态直至所有状态变为*"
"ncclSuccess*后，方可调用下一个NCCL函数。在状态转变为*ncclSuccess*前，禁止向NCCL占用的流提交CUDA内核。若通信器上发生错误，用户应通过:c:func:`ncclCommAbort`"
"销毁该通信器。通信器一旦出现错误，其上已入队操作的完成状态与正确性将无法保证。\n"
"\n"
"（注：严格遵循技术术语体系，保留所有API名称*ncclSuccess*/*ncclInProgress*等原始格式，维持GPU通信语义准确性，未添加任何解释性内容）"

#: ../../source/api/comms.rst:141 4cb9b3511b774687bdd537674d373f00
msgid "ncclCommCount"
msgstr "`ncclCommCount`"

#: ../../source/api/comms.rst:145 a278a71ed39a44d39f41df9e162abfb4
msgid "Returns in *count* the number of ranks in the NCCL communicator *comm*."
msgstr "返回 *comm* NCCL 通信器中包含的秩数量至 *count*。"

#: ../../source/api/comms.rst:148 14020e8f0d6548929a13c2beaeb05b7f
msgid "ncclCommCuDevice"
msgstr "ncclCommCuDevice"

#: ../../source/api/comms.rst:152 44f06a6ea9fb4aee8f5ee51e09824753
msgid "Returns in *device* the CUDA device associated with the NCCL communicator *comm*."
msgstr "返回与NCCL通信器*comm*关联的CUDA设备至*device*。"

#: ../../source/api/comms.rst:155 5f3dec0fe3a94ba88161932c8e178952
msgid "ncclCommUserRank"
msgstr "ncclCommUserRank"

#: ../../source/api/comms.rst:159 d7234bcdbdbf4789b5cbaa51c3908ae1
msgid "Returns in *rank* the rank of the NCCL communicator *comm*."
msgstr "返回NCCL通信器*comm*的*秩*。"

#: ../../source/api/comms.rst:162 15c68880fbab4d96904e1256a11dfc98
msgid "ncclCommRegister"
msgstr "ncclCommRegister"

#: ../../source/api/comms.rst:166 8d6d51cdf6b44ebbaaa63a55f9943a20
msgid ""
"Register buffer with *size* under communicator *comm* for zero-copy communication, and *handle* is returned for future "
"unregistration. See *buff* and *size* requirements (:ref: `user_buffer_reg`)."
msgstr "在通信器 *comm* 下注册大小为 *size* 的缓冲区以进行零拷贝通信，返回的 *handle* 将用于后续注销操作。关于 *buff* 和 *size* 的要求详见 (:ref: `user_buffer_reg`)。"

#: ../../source/api/comms.rst:170 b95e854152d54fabb81319a60c2ff735
msgid "ncclCommDeregister"
msgstr "ncclCommDeregister"

#: ../../source/api/comms.rst:174 7c982bebda1a4866bc480cf39f200374
msgid "Deregister buffer represented by *handle* under communicator *comm*."
msgstr "注销通信器*comm*下由*句柄*表示的缓冲区。"

#: ../../source/api/comms.rst:177 f1e83ab2d6ae40faa6e54d4740cd7a51
msgid "ncclMemAlloc"
msgstr "ncclMemAlloc"

#: ../../source/api/comms.rst:181 5b24c53d41264b9a9f14045bca9f758c
msgid ""
"Allocate a GPU buffer with *size*. Allocated buffer head address will be returned by *ptr*, and the actual allocated "
"size can be larger than requested because of the buffer granularity requirements from all types of NCCL optimizations."
msgstr "分配一个大小为 *size* 的 GPU 缓冲区。分配的缓冲区首地址将通过 *ptr* 返回，且实际分配的大小可能因 NCCL 各类优化所需的缓冲区粒度要求而大于请求大小。"

#: ../../source/api/comms.rst:186 984f6b2d322948eb9f412c4802367f31
msgid "ncclMemFree"
msgstr "ncclMemFree"

#: ../../source/api/comms.rst:190 6a8b05c6d4df42f28e990ae18ae21c26
msgid "Free memory allocated by *ncclMemAlloc()*."
msgstr "释放由 *ncclMemAlloc()* 分配的内存。"
