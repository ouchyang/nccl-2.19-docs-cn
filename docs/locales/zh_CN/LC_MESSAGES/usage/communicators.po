# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the NCCL(2.19) package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: NCCL(2.19)\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-27 10:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/usage/communicators.rst:5 41d1c1e46e2c43dc8e7f286440da2be1
msgid "Creating a Communicator"
msgstr "创建一个通信器"

#: ../../source/usage/communicators.rst:7 5845f106052148b38d6605b142365743
msgid ""
"When creating a communicator, a unique rank between 0 and n-1 has to be assigned to each of the n CUDA devices which "
"are part of the communicator. Using the same CUDA device multiple times as different ranks of the same NCCL "
"communicator is not supported and may lead to hangs."
msgstr "在创建通信器时，需要为通信器中的每个 CUDA 设备分配一个介于 0 和 n-1 之间的唯一等级。不支持将同一 CUDA 设备多次用作同一 NCCL 通信器的不同等级，可能会导致程序挂起。"

#: ../../source/usage/communicators.rst:11 2251b78209364067bd9a3bde6eab9c9f
msgid ""
"Given a static mapping of ranks to CUDA devices, the :c:func:`ncclCommInitRank`, :c:func:`ncclCommInitRankConfig` and "
":c:func:`ncclCommInitAll` functions will create communicator objects, each communicator object being associated to a "
"fixed rank and CUDA device. Those objects will then be used to launch communication operations."
msgstr ""
"给定一个将等级映射到CUDA设备的静态映射，:c:func:`ncclCommInitRank`、:c:func:`ncclCommInitRankConfig`和:c:func:`ncclCommInitAll`"
"函数将创建通信器对象，每个通信器对象都与一个固定的等级和CUDA设备相关联。然后，这些对象将用于启动通信操作。"

#: ../../source/usage/communicators.rst:15 7e8625ec064d450a9378cf8f24ec3c2e
msgid ""
"Before calling :c:func:`ncclCommInitRank`, you need to first create a unique object which will be used by all processes "
"and threads to synchronize and understand they are part of the same communicator. This is done by calling the "
":c:func:`ncclGetUniqueId` function."
msgstr "在调用 :c:func:`ncclCommInitRank` 之前，您需要首先创建一个唯一的对象，该对象将被所有进程和线程用于同步和理解它们属于同一个通信器。这可以通过调用 :c:func:`ncclGetUniqueId` 函数来实现。"

#: ../../source/usage/communicators.rst:19 efd1915684bf4287baa89cb19fc6e55e
msgid ""
"The :c:func:`ncclGetUniqueId` function returns an ID which has to be broadcast to all participating threads and "
"processes using any CPU communication system, for example, passing the ID pointer to multiple threads, or broadcasting "
"it to other processes using MPI or another parallel environment using, for example, sockets."
msgstr ""
":c:func:`ncclGetUniqueId` 函数返回一个 ID，必须使用任何 CPU 通信系统将其广播到所有参与的线程和进程，例如，将 ID 指针传递给多个线程，或者使用 MPI 或其他并行环境将其广播到其他进程，例如，使用 "
"sockets。"

#: ../../source/usage/communicators.rst:23 70ad93e5b3b54527b23d6b91ba9802a2
msgid ""
"You can also call the ncclCommInitAll operation to create n communicator objects at once within a single process. As it "
"is limited to a single process, this function does not permit inter-node communication. ncclCommInitAll is equivalent "
"to calling a combination of ncclGetUniqueId and ncclCommInitRank."
msgstr ""
"您也可以调用ncclCommInitAll操作，在单个进程内一次性创建n个通信器对象。由于它仅限于单个进程，此函数不允许节点间通信。ncclCommInitAll相当于调用ncclGetUniqueId和ncclCommInitRank的组"
"合。"

#: ../../source/usage/communicators.rst:27 6ca1d57949ae4fbaa1b0f3ac0815155a
msgid "The following sample code is a simplified implementation of ncclCommInitAll."
msgstr "以下示例代码是ncclCommInitAll的简化实现。"

#: ../../source/usage/communicators.rst:42
#: ../../source/usage/communicators.rst:118
#: ../../source/usage/communicators.rst:293 02c75fe054a04510a6351675377d5ea9
#: 4883f738170f46d7a4050f21d5a4ef27 819e21d0bf764da1af0c0bf1fa14fd2f
msgid "Related links:"
msgstr "相关链接："

#: ../../source/usage/communicators.rst:44 07970188f2d343c7a09bd07682468655
msgid ":c:func:`ncclCommInitAll`"
msgstr ":c:func:`ncclCommInitAll`"

#: ../../source/usage/communicators.rst:45 760019e329a043048e13773104d2e866
msgid ":c:func:`ncclGetUniqueId`"
msgstr ":c:func:`ncclGetUniqueId`"

#: ../../source/usage/communicators.rst:46 b007aa87b87e4367b79d16ab6f88cc39
msgid ":c:func:`ncclCommInitRank`"
msgstr ":c:func:`ncclCommInitRank`"

#: ../../source/usage/communicators.rst:51 7803b30891cb4e719f4344ac41e2b104
msgid "Creating a communication with options"
msgstr "创建一个带有选项的通信"

#: ../../source/usage/communicators.rst:53 193152dcc4964192a24fb5d98008b8d5
msgid "The :c:func:`ncclCommInitRankConfig` function allows to create a NCCL communication with specific options."
msgstr "`:c:func:`ncclCommInitRankConfig` 函数允许使用特定选项创建一个带有特定选项的 NCCL 通信。`"

#: ../../source/usage/communicators.rst:55 074b47ce0da549cbb71bb05569e787c0
msgid "The config parameters NCCL supports are listed here :ref:`ncclconfig`."
msgstr "NCCL支持的配置参数在这里列出：:ref:`ncclconfig`。"

#: ../../source/usage/communicators.rst:57 ef6369812ba541ca9673b90d9fb063f3
msgid ""
"For example, \"blocking\" can be set to 0 to ask NCCL to never block in any NCCL call, and at the same time other "
"config parameters can be set as well to more precisely define communicator behavior. A simple example code is shown "
"below:"
msgstr "例如，“blocking” 可以设置为 0，要求 NCCL 在任何调用中都不阻塞，同时也可以设置其他配置参数，以更精确地定义通信器的行为。下面显示了一个简单的示例代码："

#: ../../source/usage/communicators.rst:75 6197b59afe68464d84ac575f9105ed0a
msgid "Related link: :c:func:`ncclCommGetAsyncError`"
msgstr "相关链接: :c:func:`ncclCommGetAsyncError`"

#: ../../source/usage/communicators.rst:78 64988bd6a28b4b089fbea270912bf8bc
msgid "Creating more communicators"
msgstr "创建更多的沟通者"

#: ../../source/usage/communicators.rst:80 eaf0b1d3248147b185626b708e64b464
msgid ""
"The ncclCommSplit function can be used to create a communicators based on existing one. This allows to split an "
"existing communicator into multiple sub-partitions, duplicate an existing communicator, or even create a single "
"communicator with less ranks."
msgstr "`ncclCommSplit`函数可用于基于现有通信器创建通信器。这允许将现有通信器分割成多个子分区，复制现有通信器，甚至创建具有较少秩的单个通信器。"

#: ../../source/usage/communicators.rst:84 4a81340b1fd1411b96b7e70997ff35a6
msgid ""
"The ncclCommSplit function needs to be called by all ranks in the original communicator. If some ranks will not be part "
"of any sub-group, they still need to call ncclCommSplit with color being NCCL_SPLIT_NOCOLOR."
msgstr "`ncclCommSplit` 函数需要被原始通信器中的所有等级调用。如果某些等级不会成为任何子组的一部分，它们仍需要使用 `NCCL_SPLIT_NOCOLOR` 作为颜色参数调用 `ncclCommSplit`。"

#: ../../source/usage/communicators.rst:87 707189995eae4322a7e763e7dca98463
msgid ""
"Newly created communicators will inherit the parent communicator configuration (e.g. non-blocking). If the parent "
"communicator operates in non-blocking mode, a ncclCommSplit operation may be stopped by calling ncclCommAbort on the "
"parent communicator, then on any new communicator returned. This is because a hang could happen during operations on "
"any of the two communicators."
msgstr ""
"新创建的通信器将继承父通信器的配置（例如非阻塞）。如果父通信器以非阻塞模式运行，则通过在父通信器上调用ncclCommAbort，然后在返回的任何新通信器上调用，可能会导致ncclCommSplit操作被停止。这是因为在任何两个通信器上的操"
"作期间可能会发生挂起。"

#: ../../source/usage/communicators.rst:92 528cf6b55d4342a8a5c52734ce80c763
msgid "The following code duplicates an existing communicator:"
msgstr "以下代码复制了一个现有的通信器："

#: ../../source/usage/communicators.rst:100 505590f3709c4a98ab3f0964de5b6657
msgid "This splits a communicator in two halves:"
msgstr "这会把一个沟通者分成两半："

#: ../../source/usage/communicators.rst:109 06728fb656b441b79ea190bbac75bc31
msgid "This creates a communicator with only the first 2 ranks:"
msgstr "这将创建一个只包含前2个级别的通信器："

#: ../../source/usage/communicators.rst:120 b2db00783a9943448db22152e813936d
msgid ":c:func:`ncclCommSplit`"
msgstr ":c:func:`ncclCommSplit`"

#: ../../source/usage/communicators.rst:123 67d566fd37804488b5cb879b0868a4bb
msgid "Using multiple NCCL communicators concurrently"
msgstr "同时使用多个 NCCL 通信器"

#: ../../source/usage/communicators.rst:125 6d869f09d66b435c81e5c238373a41d9
msgid "Using multiple NCCL communicators requires careful synchronization, or can lead to deadlocks."
msgstr "使用多个NCCL通信器需要仔细同步，否则可能会导致死锁。"

#: ../../source/usage/communicators.rst:127 1521cf9eb20c43c7aceaa923ac88700a
msgid ""
"NCCL kernels are blocking (waiting for data to arrive), and any CUDA operation can cause a device synchronization, "
"meaning it will wait for all NCCL kernels to complete. This can quickly lead to deadlocks since NCCL operations perform "
"CUDA calls themselves."
msgstr "NCCL内核正在阻塞（等待数据到达），任何CUDA操作都可能导致设备同步，这意味着它将等待所有NCCL内核完成。这很快可能导致死锁，因为NCCL操作本身执行CUDA调用。"

#: ../../source/usage/communicators.rst:131 5ab7f07ae41f422da7bd6040fa6eb1e4
msgid ""
"Operations on different communicators should therefore be used at different epochs with a locking mechanism, and "
"applications should ensure operations are submitted in the same order across ranks."
msgstr "因此，应在不同的时期使用不同的通信器进行操作，并使用锁定机制，应用程序应确保操作按照相同的顺序在各个等级上提交。"

#: ../../source/usage/communicators.rst:134 349df2b184264c788bdc098d8248f2a2
msgid ""
"Launching multiple communication operations (on different streams) might work provided they can fit within the GPU, but "
"could break at any time if NCCL were to use more CUDA blocks per operation, or if some calls used inside NCCL "
"collectives were to perform a device synchronization (e.g. allocate some CUDA memory dynamically)."
msgstr "启动多个通信操作（在不同流上）可能有效，前提是它们可以适应 GPU，但如果 NCCL 每个操作使用更多的 CUDA 块，或者在 NCCL 集合内部使用的某些调用执行设备同步（例如动态分配一些 CUDA 内存），则可能随时中断。"

#: ../../source/usage/communicators.rst:139 a412ecfe49d14b37b27745c6aa3dbaa8
msgid "Finalizing a communicator"
msgstr "最终确定一个通信者"

#: ../../source/usage/communicators.rst:141 4c47d508fb7f434e9556633db60d5ea4
msgid ""
"ncclCommFinalize will transition a communicator from the *ncclSuccess* state to the *ncclInProgress* state, start "
"completing all operations in the background and synchronize with other ranks which may be using resources for their "
"communications with other ranks. All uncompleted operations and network-related resources associated to a communicator "
"will be flushed and freed with ncclCommFinalize. Once all NCCL operations are complete, the communicator will "
"transition to the *ncclSuccess* state. Users can query that state with ncclCommGetAsyncError. If a communicator is "
"marked as nonblocking, this operation is nonblocking; otherwise, it is blocking."
msgstr ""
"ncclCommFinalize将通信器从*ncclSuccess*状态转换为*ncclInProgress*"
"状态，开始在后台完成所有操作并与其他可能正在使用资源与其他排名进行通信的排名进行同步。所有未完成的操作和与通信器相关的网络资源将通过ncclCommFinalize被刷新和释放。一旦所有NCCL操作完成，通信器将转换为*"
"ncclSuccess*状态。用户可以使用ncclCommGetAsyncError查询该状态。如果通信器标记为非阻塞，则此操作是非阻塞的；否则，它是阻塞的。"

#: ../../source/usage/communicators.rst:150 00cc504aefe24707b270a8e93a01b458
msgid "Related link: :c:func:`ncclCommFinalize`"
msgstr "相关链接: :c:func:`ncclCommFinalize`"

#: ../../source/usage/communicators.rst:153 4363ae2da8b14e6e914ece7cfc31c4fa
msgid "Destroying a communicator"
msgstr ""

#: ../../source/usage/communicators.rst:155 31d5b056597f43ef94ed837782763db0
msgid ""
"Once a communicator has been finalized, the next step is to free all resources, including the communicator itself. "
"Local resources associated to a communicator can be destroyed with ncclCommDestroy. If the state of a communicator "
"become *ncclSuccess* before calling ncclCommDestroy, ncclCommDestroy call will guarantee nonblocking; on the contrary, "
"ncclCommDestroy might be blocked. In all cases, ncclCommDestroy call will free resources of the communicator and "
"return, and the communicator should not longer be accessed after ncclCommDestroy returns."
msgstr ""
"一旦通信器被确定，下一步是释放所有资源，包括通信器本身。与通信器相关的本地资源可以通过ncclCommDestroy进行销毁。如果在调用ncclCommDestroy之前通信器的状态变为*ncclSuccess*"
"，ncclCommDestroy调用将保证非阻塞；相反，ncclCommDestroy可能会被阻塞。在所有情况下，ncclCommDestroy调用将释放通信器的资源并返回，ncclCommDestroy返回后不应再访问通信器。"

#: ../../source/usage/communicators.rst:162 7792f545856e4a79bf1bdae1a215c447
msgid "Related link: :c:func:`ncclCommDestroy`"
msgstr "相关链接: :c:func:`ncclCommDestroy`"

#: ../../source/usage/communicators.rst:166 772ae12c023f4e269d7f75207b97b265
msgid "Error handling and communicator abort"
msgstr "错误处理和通信器中止"

#: ../../source/usage/communicators.rst:168 3bbcd32518d044be8318744fa59e1e0d
msgid ""
"All NCCL calls return a NCCL error code which is sumarized in the table below. If a NCCL call returns an error code "
"different from ncclSuccess and ncclInternalError, NCCL will print a human-readable message explaining what happened if "
"NCCL_DEBUG is set to WARN. If NCCL_DEBUG is set to INFO, it will also print the call stack which lead to the error. "
"This message is intended to help the user fix the problem."
msgstr ""
"所有NCCL调用都会返回一个NCCL错误代码，这些代码总结在下表中。如果一个NCCL调用返回的错误代码不是ncclSuccess或ncclInternalError，当NCCL_"
"DEBUG设置为WARN时，NCCL会打印一个可读的消息来解释发生了什么。如果NCCL_DEBUG设置为INFO，它还会打印导致错误的调用堆栈。这个消息旨在帮助用户解决问题。"

#: ../../source/usage/communicators.rst:173 da2a62f306a544d79b69cafb805cf1ab
msgid ""
"The table below summarizes how different errors should be understood and handled. Each case is explained in details in "
"the following sections."
msgstr "下表总结了不同错误应该如何理解和处理。每种情况在接下来的章节中都有详细解释。"

#: ../../source/usage/communicators.rst:176 1b4b5366126446b2bf80235a1def5a63
msgid "NCCL Errors"
msgstr "NCCL错误"

#: ../../source/usage/communicators.rst:180 514b7f95e881437fa1045e9c78b6ea8f
msgid "Error"
msgstr "错误"

#: ../../source/usage/communicators.rst:181 339645ef5c524ad0a6158225c71865ec
msgid "Description"
msgstr "描述"

#: ../../source/usage/communicators.rst:182 60ae4bcc91b44085ae390e2848489d8d
msgid "Resolution"
msgstr "分辨率"

#: ../../source/usage/communicators.rst:183 43017fe3370e4bb8bf24b4844e0520f5
msgid "Error handling"
msgstr "错误处理"

#: ../../source/usage/communicators.rst:184 a5557f24408e447d88cda2d662626ab5
msgid "Group behavior"
msgstr "群体行为"

#: ../../source/usage/communicators.rst:185 202cfc619db24db9a72bf70056dbeb8b
msgid "ncclSuccess"
msgstr "nccl成功"

#: ../../source/usage/communicators.rst:186 3651fbf03a784bc489ebbfe9f5e18911
msgid "No error"
msgstr "没有错误"

#: ../../source/usage/communicators.rst:187
#: ../../source/usage/communicators.rst:188
#: ../../source/usage/communicators.rst:189
#: ../../source/usage/communicators.rst:218
#: ../../source/usage/communicators.rst:219 01f1f8493c7945b3bf2e4fdb5739715f
#: 02f59428e64048acb37a0ba67fbb911d 2e3aadc2457f4bfdb0b163583e9a7f60
#: 66a8658dc7764b90be02a4b0d5c55755 dc7bdeda86814767b7627859d0c42e84
msgid "None"
msgstr ""
"Thank you for letting me know. If you have any messages you need translated in the future, feel free to send them my "
"way."

#: ../../source/usage/communicators.rst:190 7df9315cdcb74fefa44f6e18700de154
msgid "ncclUnhandledCudaError"
msgstr "ncclUnhandledCudaError"

#: ../../source/usage/communicators.rst:191 894594b4ca49404d99a8b799a6d743fe
msgid "Error during a CUDA call (1)"
msgstr "CUDA 调用时发生错误 (1)"

#: ../../source/usage/communicators.rst:192 4f6cb3341d5f4125af89d7a09e4a6c37
msgid "CUDA configuration / usage (1)"
msgstr "CUDA配置/使用（1）"

#: ../../source/usage/communicators.rst:193
#: ../../source/usage/communicators.rst:198
#: ../../source/usage/communicators.rst:203
#: ../../source/usage/communicators.rst:213 0ad1bdf2da7a444a8982e2acc4b409e7
#: 3b42e92856c04f649ee4a49cb251a1fb 3e1f6738c2d5418f930f462ffef9f463
#: c9a960cade6d45378dd6238efe8d6394
msgid "Communicator abort (5)"
msgstr "通信器中止（5）"

#: ../../source/usage/communicators.rst:194
#: ../../source/usage/communicators.rst:199
#: ../../source/usage/communicators.rst:204
#: ../../source/usage/communicators.rst:214 0962f46e26774c1fa60e1ba6ef79c1dd
#: 3205b77cf4ce4a65be625906926ebadb 3aafbd97b0e041f0bc1f46ee6a1a93a2
#: e6b08c7465224b1a89679a81a889f36b
msgid "Global (6)"
msgstr "全球 (6)"

#: ../../source/usage/communicators.rst:195 4a026078958b437bb3d678e6e42838dc
msgid "ncclSystemError"
msgstr "nccl系统错误"

#: ../../source/usage/communicators.rst:196 372ceb267c52451e917d8fd0be7276a4
msgid "Error during a system call (1)"
msgstr "系统调用（1）期间发生错误"

#: ../../source/usage/communicators.rst:197 b913f12b13df4a4ba8192837f9fd4662
msgid "System configuration / usage (1)"
msgstr "系统配置/使用（1）"

#: ../../source/usage/communicators.rst:200 23ba10bfcfc34b5db0346b7bc23350c4
msgid "ncclInternalError"
msgstr "ncclInternalError"

#: ../../source/usage/communicators.rst:201 0370bb90c50d4a18995d48f73691d8b1
msgid "Error inside NCCL (2)"
msgstr "NCCL（2）内部错误"

#: ../../source/usage/communicators.rst:202 4468656be1b74096b58c1fc0e23e6c9d
msgid "Fix in NCCL (2)"
msgstr "在 NCCL 中修复 (2)"

#: ../../source/usage/communicators.rst:205 c7f18bb3924e46059d022ca1ded789a7
msgid "ncclInvalidArgument"
msgstr "ncclInvalidArgument"

#: ../../source/usage/communicators.rst:206 f6c3c80cd2ec49588c8aeb2c523f5309
msgid "An argument to a NCCL call is invalid (3)"
msgstr "NCCL 调用的参数无效（3）"

#: ../../source/usage/communicators.rst:207 b1a435b4e1e246ea8324bfff7a7be606
msgid "Fix in the application (3)"
msgstr "在应用程序中修复（3）"

#: ../../source/usage/communicators.rst:208 20698c5533f744f59f5cb9b632651557
msgid "None (3)"
msgstr "无 (3)"

#: ../../source/usage/communicators.rst:209 139a8d2f3fdc4b479f66f9e87322c911
msgid "Individual (3)"
msgstr "个人（3）"

#: ../../source/usage/communicators.rst:210 450e68d0a6444f78ba2b1ecdf7bf8aac
msgid "ncclInvalidUsage"
msgstr "ncclInvalidUsage"

#: ../../source/usage/communicators.rst:211 6664e3df95644520a48f250f6765bdb8
msgid "The usage of NCCL calls is invalid (4)"
msgstr "NCCL 调用的使用是无效的 (4)"

#: ../../source/usage/communicators.rst:212 9843692037aa4c239d6a897216d6136c
msgid "Fix in the application (4)"
msgstr "在应用程序中修复（4）"

#: ../../source/usage/communicators.rst:215 520e4b8a566e4dcc968f42a66326b097
msgid "ncclInProgress"
msgstr "ncclInProgress"

#: ../../source/usage/communicators.rst:216 69a150c20f36418abe9260bdad590d54
msgid "The NCCL call is still in progress"
msgstr "NCCL 通话仍在进行中"

#: ../../source/usage/communicators.rst:217 c9a38b000af84440b22ce49e81537aa0
msgid "Poll for completion using ncclCommGetAsyncError"
msgstr "使用 `ncclCommGetAsyncError` 进行完成的调查"

#: ../../source/usage/communicators.rst:222 f9c7cf24ed1947209e56a6197674d7ac
msgid ""
"(1) ncclUnhandledCudaError and ncclSystemError indicate that a call NCCL made to an external component failed, which "
"caused the NCCL operation to fail. The error message should explain which component the user should look at and try to "
"fix, potentially with the help of the administrators of the system."
msgstr "(1) `ncclUnhandledCudaError`和`ncclSystemError`表示NCCL调用外部组件时失败，导致NCCL操作失败。错误消息应该解释用户应该查看和尝试修复哪个组件，可能需要系统管理员的帮助。"

#: ../../source/usage/communicators.rst:226 ec91ddce57f74c19aa73c710d08b637f
msgid ""
"(2) ncclInternalError denotes a NCCL bug. It might not report a message with NCCL_DEBUG=WARN since it requires a fix in "
"the NCCL source code. NCCL_DEBUG=INFO will print the back trace which lead to the error."
msgstr "(2) `ncclInternalError`表示NCCL的一个错误。它可能不会报告一个带有NCCL_DEBUG=WARN的消息，因为这需要在NCCL源代码中进行修复。NCCL_DEBUG=INFO将打印导致错误的回溯。"

#: ../../source/usage/communicators.rst:229 e88a3b21bd64437699e3b60facb23fc9
msgid ""
"(3) ncclInvalidArgument indicates an argument value is incorrect, like a NULL pointer, or an out-of-bounds value. When "
"this error is returned, the NCCL call had no effect. The group state remains unchanged, the communicator is still "
"functioning normally. The application can call ncclCommAbort or continue as if the call did not happen. This error will "
"be returned immediately for a call happening within a group and applies to that specific NCCL call. It will not be "
"returned by ncclGroupEnd since ncclGroupEnd takes no argument."
msgstr ""
"(3) `ncclInvalidArgument` 表示参数值不正确，比如空指针或超出范围的值。当出现此错误时，NCCL 调用没有效果。群组状态保持不变，通信器仍然正常运行。应用程序可以调用 `ncclCommAbort` "
"或继续，就好像调用没有发生一样。此错误将立即返回给在群组内发生的调用，并仅适用于该特定的 NCCL 调用。它不会被 `ncclGroupEnd` 返回，因为 `ncclGroupEnd` 不接受任何参数。"

#: ../../source/usage/communicators.rst:235 a1c9c08b15be4949b0ee137cd25f7a08
msgid ""
"(4) ncclInvalidUsage is returned when a dynamic condition causes a failure, which denotes an incorrect usage of the "
"NCCL API."
msgstr "当动态条件导致失败时，会返回`ncclInvalidUsage`，表示对NCCL API的错误使用。"

#: ../../source/usage/communicators.rst:238 f87f2bd5cedf417e99461473dae71cb3
msgid ""
"(5) These errors are fatal for the communicator. To recover, the application needs to call ncclCommAbort on the "
"communicator and re-create it."
msgstr "这些错误对通信者来说是致命的。要恢复，应用程序需要在通信者上调用ncclCommAbort，然后重新创建它。"

#: ../../source/usage/communicators.rst:241 41081f69c004402e9b69814d1cd4b546
msgid ""
"(6) Dynamic errors for operations within a group are always reported by ncclGroupEnd and apply to all operations within "
"the group, which may or may not have completed. The application must call ncclCommAbort on all communicators within the "
"group."
msgstr "(6) 组内操作的动态错误始终由 ncclGroupEnd 报告，并适用于组内的所有操作，这些操作可能已经完成，也可能尚未完成。应用程序必须在组内的所有通信器上调用 ncclCommAbort。"

#: ../../source/usage/communicators.rst:246 8b8485369ef84cde831b0d498b4816ad
msgid "Asynchronous errors and error handling"
msgstr "异步错误和错误处理"

#: ../../source/usage/communicators.rst:248 80f64453837e4bde878beac42c69458b
msgid ""
"Some communication errors, and in particular network errors, are reported through the ncclCommGetAsyncError function. "
"Operations experiencing an asynchronous error will usually not progress and never complete. When an asynchronous error "
"happens, the operation should be aborted and the communicator destroyed using ncclCommAbort. When waiting for NCCL "
"operations to complete, applications should call ncclCommGetAsyncError and destroy the communicator when an error "
"happens."
msgstr ""
"通常，通过`ncclCommGetAsyncError`函数报告一些通信错误，特别是网络错误。遇到异步错误的操作通常不会继续进行，也永远不会完成。当发生异步错误时，应中止操作并使用`ncclCommAbort`"
"销毁通信器。在等待NCCL操作完成时，应用程序应调用`ncclCommGetAsyncError`，并在发生错误时销毁通信器。"

#: ../../source/usage/communicators.rst:254 cb22fe21de304978b2d9976a4058c930
msgid ""
"The following code shows how to wait on NCCL operations and poll for asynchronous errors, instead of using "
"cudaStreamSynchronize."
msgstr "以下代码展示了如何等待NCCL操作并轮询异步错误，而不是使用cudaStreamSynchronize。"

#: ../../source/usage/communicators.rst:295 d353774451094bb28d72a513b4eeae28
msgid ":c:func:`ncclCommGetAsyncError`"
msgstr ":c:func:`ncclCommGetAsyncError`"

#: ../../source/usage/communicators.rst:296 2042fe0d225f4701804476141373a5b9
msgid ":c:func:`ncclCommAbort`"
msgstr ":c:func:`ncclCommAbort`"

#: ../../source/usage/communicators.rst:300 20e67e46444b4707a3d537c7a69afbf9
msgid "Fault Tolerance"
msgstr "容错性"

#: ../../source/usage/communicators.rst:302 6441a774f51f4c27bba44b6e027ad4a4
msgid ""
"NCCL provides a set of features to allow applications to recover from fatal errors such as network failure, node "
"failure, or process failure. When such an error happens, the application should be able to call ncclCommAbort on the "
"communicator to free all resources, then recreate a new communicator to continue. All NCCL calls can be non-blocking to "
"ensure ncclCommAbort can be called at any point, during initialization, communication or when finalizing the "
"communicator."
msgstr ""
"NCCL提供了一组功能，允许应用程序从致命错误（如网络故障、节点故障或进程故障）中恢复。当发生此类错误时，应用程序应能够在通信器上调用ncclCommAbort以释放所有资源，然后重新创建一个新的通信器以继续。所有NCCL调用都可以是非阻塞"
"的，以确保可以在任何时候调用ncclCommAbort，无论是在初始化、通信还是在完成通信器时。"

#: ../../source/usage/communicators.rst:308 bbfdc020ff1849d188cb81c96403afed
msgid ""
"To correctly abort, when any rank in a communicator fails (e.g., due to segmentation fault), all other ranks need to "
"call *ncclCommAbort* to abort their own NCCL communicator. Users can implement methods to decide when and whether to "
"abort the communicators and restart the NCCL operation. Here is an example showing how to initialize and split a "
"communicator in a non-blocking manner, allowing for abort at any point:"
msgstr ""
"为了正确中止，当通信器中的任何等级失败（例如，由于分段错误），所有其他等级都需要调用 *ncclCommAbort* 来中止他们自己的 NCCL 通信器。用户可以实现方法来决定何时以及是否中止通信器并重新启动 NCCL "
"操作。以下是一个示例，展示了如何以非阻塞方式初始化和分割通信器，允许在任何时刻中止："

#: ../../source/usage/communicators.rst:357 9bdc3b4fe16e40e2a530763dbd70960a
msgid ""
"*checkTimeout* function is just an example and provided by users to determine what is the longest time the application "
"should wait for NCCL initialization; likewise, users can apply other methods to detect errors besides timeout function. "
"Similar methods can be applied to NCCL finalization as well."
msgstr "*checkTimeout* 函数只是一个示例，由用户提供以确定应用程序等待 NCCL 初始化的最长时间；同样，用户可以应用其他方法来检测错误，而不仅仅是超时函数。类似的方法也可以应用于 NCCL 结束。"
