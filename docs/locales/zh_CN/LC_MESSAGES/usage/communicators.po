# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the NCCL(2.19) package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: NCCL(2.19)\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-27 11:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/usage/communicators.rst:5 b06e70c76a7348af80756d1dec9b76aa
msgid "Creating a Communicator"
msgstr "创建一个通讯器"

#: ../../source/usage/communicators.rst:7 746a36e7f217447aa9e50e42f7fb9c09
msgid ""
"When creating a communicator, a unique rank between 0 and n-1 has to be assigned to each of the n CUDA devices which "
"are part of the communicator. Using the same CUDA device multiple times as different ranks of the same NCCL "
"communicator is not supported and may lead to hangs."
msgstr "在创建通信器时，需要为通信器中的每个 CUDA 设备分配一个介于 0 和 n-1 之间的唯一等级。不支持将同一 CUDA 设备多次用作同一 NCCL 通信器的不同等级，可能会导致程序挂起。"

#: ../../source/usage/communicators.rst:11 64448fc1c3d04eeab0774e3d7b062992
msgid ""
"Given a static mapping of ranks to CUDA devices, the :c:func:`ncclCommInitRank`, :c:func:`ncclCommInitRankConfig` and "
":c:func:`ncclCommInitAll` functions will create communicator objects, each communicator object being associated to a "
"fixed rank and CUDA device. Those objects will then be used to launch communication operations."
msgstr ""
"给定一个将等级映射到CUDA设备的静态映射，:c:func:`ncclCommInitRank`、:c:func:`ncclCommInitRankConfig`和:c:func:`ncclCommInitAll`"
"函数将创建通信器对象，每个通信器对象都与固定的等级和CUDA设备相关联。然后，这些对象将用于启动通信操作。"

#: ../../source/usage/communicators.rst:15 4abd051e3fef4943a3364edfdc9c83f9
msgid ""
"Before calling :c:func:`ncclCommInitRank`, you need to first create a unique object which will be used by all processes "
"and threads to synchronize and understand they are part of the same communicator. This is done by calling the "
":c:func:`ncclGetUniqueId` function."
msgstr "在调用 :c:func:`ncclCommInitRank` 之前，您需要首先创建一个唯一的对象，该对象将被所有进程和线程用于同步和理解它们属于同一个通信器。这可以通过调用 :c:func:`ncclGetUniqueId` 函数来实现。"

#: ../../source/usage/communicators.rst:19 36a9ffe19ef04ca9adf0a27556ecf89e
msgid ""
"The :c:func:`ncclGetUniqueId` function returns an ID which has to be broadcast to all participating threads and "
"processes using any CPU communication system, for example, passing the ID pointer to multiple threads, or broadcasting "
"it to other processes using MPI or another parallel environment using, for example, sockets."
msgstr ""
":c:func:`ncclGetUniqueId` 函数返回一个 ID，必须使用任何 CPU 通信系统将其广播到所有参与的线程和进程，例如，将 ID 指针传递给多个线程，或者使用 MPI 或另一个并行环境将其广播到其他进程，例如，使用 "
"sockets。"

#: ../../source/usage/communicators.rst:23 508d193063ab4e9ab41a6bddde09d962
msgid ""
"You can also call the ncclCommInitAll operation to create n communicator objects at once within a single process. As it "
"is limited to a single process, this function does not permit inter-node communication. ncclCommInitAll is equivalent "
"to calling a combination of ncclGetUniqueId and ncclCommInitRank."
msgstr ""
"您也可以调用ncclCommInitAll操作，在单个进程中一次性创建n个通信器对象。由于它仅限于单个进程，此函数不允许节点间通信。ncclCommInitAll相当于调用ncclGetUniqueId和ncclCommInitRank的组"
"合。"

#: ../../source/usage/communicators.rst:27 0d311beebf7b4fa2aa839a1a3d6d612e
msgid "The following sample code is a simplified implementation of ncclCommInitAll."
msgstr "以下示例代码是ncclCommInitAll的简化实现。"

#: ../../source/usage/communicators.rst:42
#: ../../source/usage/communicators.rst:118
#: ../../source/usage/communicators.rst:293 bcc73913a7054b7bb70a7b60be97ea0a
#: d387fbadbe0240c4b2b86879eb452e91 ef9340ae13c445ac81c2af6d28da4810
msgid "Related links:"
msgstr "相关链接："

#: ../../source/usage/communicators.rst:44 26cb547aa6a14b9d82e35cac5ce46939
msgid ":c:func:`ncclCommInitAll`"
msgstr ":c:func:`ncclCommInitAll`"

#: ../../source/usage/communicators.rst:45 06cc30a835894e1cbc9a9fb4e1fbb236
msgid ":c:func:`ncclGetUniqueId`"
msgstr ":c:func:`ncclGetUniqueId`"

#: ../../source/usage/communicators.rst:46 1c2fa35d66ab4761bd4a04e08616ef0f
msgid ":c:func:`ncclCommInitRank`"
msgstr ":c:func:`ncclCommInitRank`"

#: ../../source/usage/communicators.rst:51 4a5a561642424fffa9e40da0e8d52215
msgid "Creating a communication with options"
msgstr "创建一个带有选项的通信"

#: ../../source/usage/communicators.rst:53 ff938a1dd4504538beec1c825de3fd14
msgid "The :c:func:`ncclCommInitRankConfig` function allows to create a NCCL communication with specific options."
msgstr "`:c:func:`ncclCommInitRankConfig` 函数允许使用特定选项创建一个带有特定选项的 NCCL 通信。`"

#: ../../source/usage/communicators.rst:55 a7896af64dbd4676894971e81c07ac65
msgid "The config parameters NCCL supports are listed here :ref:`ncclconfig`."
msgstr "NCCL支持的配置参数在这里列出：:ref:`ncclconfig`。"

#: ../../source/usage/communicators.rst:57 2185c9265eec4f86aa288f90c4987e8f
msgid ""
"For example, \"blocking\" can be set to 0 to ask NCCL to never block in any NCCL call, and at the same time other "
"config parameters can be set as well to more precisely define communicator behavior. A simple example code is shown "
"below:"
msgstr "例如，可以将“blocking”设置为0，要求NCCL在任何NCCL调用中都不阻塞，同时也可以设置其他配置参数，以更精确地定义通信器的行为。下面显示了一个简单的示例代码："

#: ../../source/usage/communicators.rst:75 9cbba689b6c84f8dac54d8f87d5db75c
msgid "Related link: :c:func:`ncclCommGetAsyncError`"
msgstr "相关链接: :c:func:`ncclCommGetAsyncError`"

#: ../../source/usage/communicators.rst:78 8a86263c3c2d43449830a8ba2297638d
msgid "Creating more communicators"
msgstr "创建更多的沟通者"

#: ../../source/usage/communicators.rst:80 0adf5c5c30e34a0e9c4356ddb6f9434e
msgid ""
"The ncclCommSplit function can be used to create a communicators based on existing one. This allows to split an "
"existing communicator into multiple sub-partitions, duplicate an existing communicator, or even create a single "
"communicator with less ranks."
msgstr "`ncclCommSplit` 函数可用于基于现有通信器创建通信器。这允许将现有通信器分割成多个子分区，复制现有通信器，甚至创建具有较少秩的单个通信器。"

#: ../../source/usage/communicators.rst:84 6fd64598b2234c82a095ee2088d5531f
msgid ""
"The ncclCommSplit function needs to be called by all ranks in the original communicator. If some ranks will not be part "
"of any sub-group, they still need to call ncclCommSplit with color being NCCL_SPLIT_NOCOLOR."
msgstr "`ncclCommSplit` 函数需要被原始通信器中的所有等级调用。如果某些等级不会成为任何子组的一部分，它们仍需要使用 `NCCL_SPLIT_NOCOLOR` 作为颜色参数调用 `ncclCommSplit`。"

#: ../../source/usage/communicators.rst:87 f7f78e39b2904b45a99e76b042033307
msgid ""
"Newly created communicators will inherit the parent communicator configuration (e.g. non-blocking). If the parent "
"communicator operates in non-blocking mode, a ncclCommSplit operation may be stopped by calling ncclCommAbort on the "
"parent communicator, then on any new communicator returned. This is because a hang could happen during operations on "
"any of the two communicators."
msgstr ""
"新创建的通信器将继承父通信器的配置（例如非阻塞）。如果父通信器以非阻塞模式运行，则通过在父通信器上调用ncclCommAbort，然后在返回的任何新通信器上调用，可能会导致ncclCommSplit操作被停止。这是因为在任何两个通信器上的操"
"作期间可能会发生挂起。"

#: ../../source/usage/communicators.rst:92 4eff8c07a0294b27b3067a72b8827c22
msgid "The following code duplicates an existing communicator:"
msgstr "以下代码复制了一个现有的通信器："

#: ../../source/usage/communicators.rst:100 2c206cbf55d645d687ff2db61e7d7323
msgid "This splits a communicator in two halves:"
msgstr "这会把一个交流者分成两半："

#: ../../source/usage/communicators.rst:109 22e47f37d4fa4723acb4b71984f0dc11
msgid "This creates a communicator with only the first 2 ranks:"
msgstr "这将创建一个只包含前两个级别的通信器："

#: ../../source/usage/communicators.rst:120 3e78498d1b4e43f8afc8cdad5248aa47
msgid ":c:func:`ncclCommSplit`"
msgstr ":c:func:`ncclCommSplit`"

#: ../../source/usage/communicators.rst:123 b7005b5a2b5640a3a27427f84bbb4c4a
msgid "Using multiple NCCL communicators concurrently"
msgstr "同时使用多个 NCCL 通信器"

#: ../../source/usage/communicators.rst:125 dd5cfde4b62a4c8daccdd7c75d210a43
msgid "Using multiple NCCL communicators requires careful synchronization, or can lead to deadlocks."
msgstr "使用多个NCCL通信器需要仔细同步，否则可能会导致死锁。"

#: ../../source/usage/communicators.rst:127 674d2496979249c7b888bf0b11f00d46
msgid ""
"NCCL kernels are blocking (waiting for data to arrive), and any CUDA operation can cause a device synchronization, "
"meaning it will wait for all NCCL kernels to complete. This can quickly lead to deadlocks since NCCL operations perform "
"CUDA calls themselves."
msgstr "NCCL内核正在阻塞（等待数据到达），任何CUDA操作都可能导致设备同步，这意味着它将等待所有NCCL内核完成。这很快可能导致死锁，因为NCCL操作本身执行CUDA调用。"

#: ../../source/usage/communicators.rst:131 7384e3742e504df981b4ae238efa8f81
msgid ""
"Operations on different communicators should therefore be used at different epochs with a locking mechanism, and "
"applications should ensure operations are submitted in the same order across ranks."
msgstr "因此，应在不同的时期使用不同的通信器进行操作，并配合锁定机制，应用程序应确保操作按照相同的顺序在各个等级上提交。"

#: ../../source/usage/communicators.rst:134 b0f950fcca0f426380a32713138b13f7
msgid ""
"Launching multiple communication operations (on different streams) might work provided they can fit within the GPU, but "
"could break at any time if NCCL were to use more CUDA blocks per operation, or if some calls used inside NCCL "
"collectives were to perform a device synchronization (e.g. allocate some CUDA memory dynamically)."
msgstr "启动多个通信操作（在不同流上）可能有效，前提是它们可以适应 GPU，但如果 NCCL 每个操作使用更多的 CUDA 块，或者在 NCCL 集合内部使用的某些调用执行设备同步（例如动态分配一些 CUDA 内存），则可能会在任何时候中断。"

#: ../../source/usage/communicators.rst:139 f98b2bbee2c54dd1a57459453d7760d4
msgid "Finalizing a communicator"
msgstr "最终确定一个通信者"

#: ../../source/usage/communicators.rst:141 ea1f6e9cb1524a9bb5d394be0ec867f7
msgid ""
"ncclCommFinalize will transition a communicator from the *ncclSuccess* state to the *ncclInProgress* state, start "
"completing all operations in the background and synchronize with other ranks which may be using resources for their "
"communications with other ranks. All uncompleted operations and network-related resources associated to a communicator "
"will be flushed and freed with ncclCommFinalize. Once all NCCL operations are complete, the communicator will "
"transition to the *ncclSuccess* state. Users can query that state with ncclCommGetAsyncError. If a communicator is "
"marked as nonblocking, this operation is nonblocking; otherwise, it is blocking."
msgstr ""
"ncclCommFinalize将通信器从*ncclSuccess*状态转换为*ncclInProgress*"
"状态，开始在后台完成所有操作并与其他可能正在使用资源与其他排名进行通信的排名进行同步。所有未完成的操作和与通信器相关的网络资源将通过ncclCommFinalize被刷新和释放。一旦所有NCCL操作完成，通信器将转换为*"
"ncclSuccess*状态。用户可以使用ncclCommGetAsyncError查询该状态。如果通信器标记为非阻塞，则此操作是非阻塞的；否则，它是阻塞的。"

#: ../../source/usage/communicators.rst:150 ec1cfb1b76084d0e8a9f95f331681d20
msgid "Related link: :c:func:`ncclCommFinalize`"
msgstr "相关链接: :c:func:`ncclCommFinalize`"

#: ../../source/usage/communicators.rst:153 53ad1ba451274f719ece604716b6af17
msgid "Destroying a communicator"
msgstr "摧毁通讯器"

#: ../../source/usage/communicators.rst:155 154b1f9ed8824b6ba2e5900ff237a0b6
msgid ""
"Once a communicator has been finalized, the next step is to free all resources, including the communicator itself. "
"Local resources associated to a communicator can be destroyed with ncclCommDestroy. If the state of a communicator "
"become *ncclSuccess* before calling ncclCommDestroy, ncclCommDestroy call will guarantee nonblocking; on the contrary, "
"ncclCommDestroy might be blocked. In all cases, ncclCommDestroy call will free resources of the communicator and "
"return, and the communicator should not longer be accessed after ncclCommDestroy returns."
msgstr ""
"一旦通信器已经确定，下一步是释放所有资源，包括通信器本身。与通信器相关的本地资源可以通过ncclCommDestroy进行销毁。如果在调用ncclCommDestroy之前通信器的状态变为*ncclSuccess*"
"，ncclCommDestroy调用将保证非阻塞；相反，ncclCommDestroy可能会被阻塞。在所有情况下，ncclCommDestroy调用将释放通信器的资源并返回，通信器在ncclCommDestroy返回后不应再被访问。"

#: ../../source/usage/communicators.rst:162 4a32c6def4d94630940bbc198a7bc78e
msgid "Related link: :c:func:`ncclCommDestroy`"
msgstr "相关链接: :c:func:`ncclCommDestroy`"

#: ../../source/usage/communicators.rst:166 f5cf421d1b6147288cbda4adbcc9747d
msgid "Error handling and communicator abort"
msgstr "错误处理和通信器中止"

#: ../../source/usage/communicators.rst:168 97bf6a8815b74edab42127299aa2b4e4
msgid ""
"All NCCL calls return a NCCL error code which is sumarized in the table below. If a NCCL call returns an error code "
"different from ncclSuccess and ncclInternalError, NCCL will print a human-readable message explaining what happened if "
"NCCL_DEBUG is set to WARN. If NCCL_DEBUG is set to INFO, it will also print the call stack which lead to the error. "
"This message is intended to help the user fix the problem."
msgstr ""
"所有 NCCL 调用都会返回一个在下表中总结的 NCCL 错误代码。如果一个 NCCL 调用返回的错误代码不是 ncclSuccess 或 ncclInternalError，当 NCCL_DEBUG 设置为 WARN 时，NCCL "
"将打印一个可读的消息来解释发生了什么。如果 NCCL_DEBUG 设置为 INFO，它还会打印导致错误的调用堆栈。这条消息旨在帮助用户解决问题。"

#: ../../source/usage/communicators.rst:173 06e9f15d3d044a5ebbd796185c31160b
msgid ""
"The table below summarizes how different errors should be understood and handled. Each case is explained in details in "
"the following sections."
msgstr "下表总结了不同错误应该如何理解和处理。每种情况在接下来的章节中都有详细解释。"

#: ../../source/usage/communicators.rst:176 4a4e4cf8b79d4e268bf19822fe2a852f
msgid "NCCL Errors"
msgstr "NCCL错误"

#: ../../source/usage/communicators.rst:180 aacce423a7994a3d9bef6212e0f0eb5d
msgid "Error"
msgstr "错误"

#: ../../source/usage/communicators.rst:181 0ab15e6d2ac346f99f093a686f6e41bd
msgid "Description"
msgstr "描述"

#: ../../source/usage/communicators.rst:182 acf7492a8fbe44e3907c3c3ac525c395
msgid "Resolution"
msgstr "决议"

#: ../../source/usage/communicators.rst:183 c0f4af167bd141ef92d4d4faa190ea72
msgid "Error handling"
msgstr "错误处理"

#: ../../source/usage/communicators.rst:184 90f69716008b49cd8042343ba83b1a5a
msgid "Group behavior"
msgstr "群体行为"

#: ../../source/usage/communicators.rst:185 efc3c2eaa655445e9d626e70cfb2e4c0
msgid "ncclSuccess"
msgstr "nccl成功"

#: ../../source/usage/communicators.rst:186 f632aed36dad4dacbf3aac8a45bc7ecd
msgid "No error"
msgstr "没有错误"

#: ../../source/usage/communicators.rst:187
#: ../../source/usage/communicators.rst:188
#: ../../source/usage/communicators.rst:189
#: ../../source/usage/communicators.rst:218
#: ../../source/usage/communicators.rst:219 44f58b6a7bd94d4da89ac623af40b62e
#: 76957a35dc8d4f17a86a431448274fd8 77f00c2969be43fe971ab72d08b80b95
#: db136b01f8a3457990075fc9ec0f24a9 dc6616d50d48424188ffb2d777d37bd9
msgid "None"
msgstr ""
"Thank you for letting me know. If you have any messages you'd like me to translate in the future, feel free to send "
"them my way."

#: ../../source/usage/communicators.rst:190 c8f7b34ef72a48d9b6e12817d18192e5
msgid "ncclUnhandledCudaError"
msgstr "ncclUnhandledCudaError"

#: ../../source/usage/communicators.rst:191 38779c0c034d4b37b3193fffa5f0b2a2
msgid "Error during a CUDA call (1)"
msgstr "CUDA 调用时发生错误 (1)"

#: ../../source/usage/communicators.rst:192 75b33ad27fd24a208d6f4b2155d0e1a2
msgid "CUDA configuration / usage (1)"
msgstr "CUDA配置/使用（1）"

#: ../../source/usage/communicators.rst:193
#: ../../source/usage/communicators.rst:198
#: ../../source/usage/communicators.rst:203
#: ../../source/usage/communicators.rst:213 3e38c2cb6bf742d09c941daf9fe4315f
#: 491bb4da911d4517b12d9f5225a2cd59 7fbafee6fd9c4239aeeaf88d776c3fad
#: abaf93fada7c430dbe98c3bafc63fa1d
msgid "Communicator abort (5)"
msgstr "通信器中止（5）"

#: ../../source/usage/communicators.rst:194
#: ../../source/usage/communicators.rst:199
#: ../../source/usage/communicators.rst:204
#: ../../source/usage/communicators.rst:214 19ed3434b22f49ca89b2f6c1d6ea03ed
#: 2e437895d0724034aaf49a98c0e3fc75 77ab3ab111fa4f21a4cb160eaff2cb46
#: 7bbd56d3187849d0b82f5900a220ebf9
msgid "Global (6)"
msgstr "全球 (6)"

#: ../../source/usage/communicators.rst:195 70d8adad9f20483bb8446b9df74eed73
msgid "ncclSystemError"
msgstr "nccl系统错误"

#: ../../source/usage/communicators.rst:196 43b846eb11b643d89de92ba792906030
msgid "Error during a system call (1)"
msgstr "系统调用（1）期间发生错误"

#: ../../source/usage/communicators.rst:197 7e1bc7e17255444ca1faf2812a9fa9e4
msgid "System configuration / usage (1)"
msgstr "系统配置 / 使用 (1)"

#: ../../source/usage/communicators.rst:200 b53126a314bf4307a3af0c8c788aec07
msgid "ncclInternalError"
msgstr "ncclInternalError"

#: ../../source/usage/communicators.rst:201 44d7a4143a8f427abb5ad4cdf132e054
msgid "Error inside NCCL (2)"
msgstr "NCCL（2）内部错误"

#: ../../source/usage/communicators.rst:202 78d5523520ea4a03a00e27a45f26d4b7
msgid "Fix in NCCL (2)"
msgstr "在 NCCL 中修复 (2)"

#: ../../source/usage/communicators.rst:205 24dae4438b5e4e0eb0e86e6252cbb35a
msgid "ncclInvalidArgument"
msgstr "ncclInvalidArgument"

#: ../../source/usage/communicators.rst:206 3325e1e001044823bd26c48e44d64880
msgid "An argument to a NCCL call is invalid (3)"
msgstr "NCCL 调用的参数无效（3）"

#: ../../source/usage/communicators.rst:207 bc5a79d9c1434e8eaaa1001c4e490a3a
msgid "Fix in the application (3)"
msgstr "在应用程序中修复（3）"

#: ../../source/usage/communicators.rst:208 0b4700b653fb48acac69801595e3fc51
msgid "None (3)"
msgstr "无 (3)"

#: ../../source/usage/communicators.rst:209 f51f09f741944c5ca0e004f6aa6b9cba
msgid "Individual (3)"
msgstr "个人（3）"

#: ../../source/usage/communicators.rst:210 2576da1d13704ec788f86c98a0cec0b0
msgid "ncclInvalidUsage"
msgstr "ncclInvalidUsage"

#: ../../source/usage/communicators.rst:211 a584e56b1cda4738b8b5e6a28df16908
msgid "The usage of NCCL calls is invalid (4)"
msgstr "NCCL 调用的使用是无效的 (4)"

#: ../../source/usage/communicators.rst:212 e57c068f4dd7489bbfaa319827d8fc70
msgid "Fix in the application (4)"
msgstr "在应用程序中修复（4）"

#: ../../source/usage/communicators.rst:215 475846ff17fa4ce18e54108d5db35d82
msgid "ncclInProgress"
msgstr "ncclInProgress"

#: ../../source/usage/communicators.rst:216 59cc563f97f04e128321eff21e3fe6c8
msgid "The NCCL call is still in progress"
msgstr "NCCL 通话仍在进行中"

#: ../../source/usage/communicators.rst:217 fa0741ccc3614a8d9ba982ca981281f4
msgid "Poll for completion using ncclCommGetAsyncError"
msgstr "使用 `ncclCommGetAsyncError` 进行完成的调查"

#: ../../source/usage/communicators.rst:222 ef30bc6a5ae541fd9dfb4ad2bcf9400e
msgid ""
"(1) ncclUnhandledCudaError and ncclSystemError indicate that a call NCCL made to an external component failed, which "
"caused the NCCL operation to fail. The error message should explain which component the user should look at and try to "
"fix, potentially with the help of the administrators of the system."
msgstr "(1) `ncclUnhandledCudaError`和`ncclSystemError`表示NCCL调用外部组件时失败，导致NCCL操作失败。错误消息应该解释用户应该查看和尝试修复哪个组件，可能需要系统管理员的帮助。"

#: ../../source/usage/communicators.rst:226 6a1bf4f9815148df9593debf12731bf2
msgid ""
"(2) ncclInternalError denotes a NCCL bug. It might not report a message with NCCL_DEBUG=WARN since it requires a fix in "
"the NCCL source code. NCCL_DEBUG=INFO will print the back trace which lead to the error."
msgstr "(2) `ncclInternalError`表示NCCL的一个错误。由于需要在NCCL源代码中进行修复，可能不会使用`NCCL_DEBUG=WARN`报告消息。`NCCL_DEBUG=INFO`将打印导致错误的回溯。"

#: ../../source/usage/communicators.rst:229 ded8f8ed9d1e476aaa594ead2598165e
msgid ""
"(3) ncclInvalidArgument indicates an argument value is incorrect, like a NULL pointer, or an out-of-bounds value. When "
"this error is returned, the NCCL call had no effect. The group state remains unchanged, the communicator is still "
"functioning normally. The application can call ncclCommAbort or continue as if the call did not happen. This error will "
"be returned immediately for a call happening within a group and applies to that specific NCCL call. It will not be "
"returned by ncclGroupEnd since ncclGroupEnd takes no argument."
msgstr ""
"(3) `ncclInvalidArgument` 表示参数值不正确，比如空指针或超出范围的值。当出现此错误时，NCCL 调用没有效果。群组状态保持不变，通信器仍然正常运行。应用程序可以调用 `ncclCommAbort` "
"或继续，就好像调用没有发生一样。此错误将立即返回，适用于组内发生的调用，并且仅适用于特定的 NCCL 调用。它不会被 `ncclGroupEnd` 返回，因为 `ncclGroupEnd` 不接受任何参数。"

#: ../../source/usage/communicators.rst:235 4c55facbf99b47bc85b60c91ddafa0be
msgid ""
"(4) ncclInvalidUsage is returned when a dynamic condition causes a failure, which denotes an incorrect usage of the "
"NCCL API."
msgstr "(4) 当动态条件导致失败时，将返回 ncclInvalidUsage，这表示对 NCCL API 的不正确使用。"

#: ../../source/usage/communicators.rst:238 ecee101597d547b49161e49ada675936
msgid ""
"(5) These errors are fatal for the communicator. To recover, the application needs to call ncclCommAbort on the "
"communicator and re-create it."
msgstr "(5) 这些错误对通信者来说是致命的。要恢复，应用程序需要在通信者上调用ncclCommAbort并重新创建它。"

#: ../../source/usage/communicators.rst:241 9e32fae12dd0414abc3edca5c249a0b9
msgid ""
"(6) Dynamic errors for operations within a group are always reported by ncclGroupEnd and apply to all operations within "
"the group, which may or may not have completed. The application must call ncclCommAbort on all communicators within the "
"group."
msgstr "(6) 组内操作的动态错误始终由 ncclGroupEnd 报告，并适用于组内的所有操作，这些操作可能已经完成，也可能尚未完成。应用程序必须在组内的所有通信器上调用 ncclCommAbort。"

#: ../../source/usage/communicators.rst:246 688e6013410f45559d4bd1273277f9de
msgid "Asynchronous errors and error handling"
msgstr "异步错误和错误处理"

#: ../../source/usage/communicators.rst:248 5dfde90a9fd142beb3a414c2a42d6f88
msgid ""
"Some communication errors, and in particular network errors, are reported through the ncclCommGetAsyncError function. "
"Operations experiencing an asynchronous error will usually not progress and never complete. When an asynchronous error "
"happens, the operation should be aborted and the communicator destroyed using ncclCommAbort. When waiting for NCCL "
"operations to complete, applications should call ncclCommGetAsyncError and destroy the communicator when an error "
"happens."
msgstr ""
"通常，通过`ncclCommGetAsyncError`函数报告一些通信错误，特别是网络错误。遇到异步错误的操作通常不会继续进行，也永远不会完成。当发生异步错误时，应中止操作并使用`ncclCommAbort`"
"销毁通信器。在等待NCCL操作完成时，应用程序应调用`ncclCommGetAsyncError`，并在发生错误时销毁通信器。"

#: ../../source/usage/communicators.rst:254 01711fc8a078481899c27d4cdf8131c2
msgid ""
"The following code shows how to wait on NCCL operations and poll for asynchronous errors, instead of using "
"cudaStreamSynchronize."
msgstr "以下代码展示了如何等待NCCL操作并轮询异步错误，而不是使用cudaStreamSynchronize。"

#: ../../source/usage/communicators.rst:295 9f860b0b9b7b432db4d8bb0933d0a769
msgid ":c:func:`ncclCommGetAsyncError`"
msgstr ":c:func:`ncclCommGetAsyncError`"

#: ../../source/usage/communicators.rst:296 344e976717fb4b9e851036e03ceb9c27
msgid ":c:func:`ncclCommAbort`"
msgstr ":c:func:`ncclCommAbort`"

#: ../../source/usage/communicators.rst:300 2db435f911b04712a7a3ef6cc1db90fc
msgid "Fault Tolerance"
msgstr "容错能力"

#: ../../source/usage/communicators.rst:302 95ada6a7832e4ca5b60a012d655db553
msgid ""
"NCCL provides a set of features to allow applications to recover from fatal errors such as network failure, node "
"failure, or process failure. When such an error happens, the application should be able to call ncclCommAbort on the "
"communicator to free all resources, then recreate a new communicator to continue. All NCCL calls can be non-blocking to "
"ensure ncclCommAbort can be called at any point, during initialization, communication or when finalizing the "
"communicator."
msgstr ""
"NCCL提供了一组功能，允许应用程序从致命错误（如网络故障、节点故障或进程故障）中恢复。当发生此类错误时，应用程序应能够调用ncclCommAbort来释放所有资源，然后重新创建一个新的通信器以继续。所有NCCL调用都可以是非阻塞的，以确保"
"可以在任何时候调用ncclCommAbort，无论是在初始化、通信还是在完成通信器时。"

#: ../../source/usage/communicators.rst:308 10636eb1642a45378745a3977081aa8a
msgid ""
"To correctly abort, when any rank in a communicator fails (e.g., due to segmentation fault), all other ranks need to "
"call *ncclCommAbort* to abort their own NCCL communicator. Users can implement methods to decide when and whether to "
"abort the communicators and restart the NCCL operation. Here is an example showing how to initialize and split a "
"communicator in a non-blocking manner, allowing for abort at any point:"
msgstr ""
"为了正确中止，当通信器中的任何等级失败（例如，由于分段错误），所有其他等级都需要调用 *ncclCommAbort* 来中止他们自己的 NCCL 通信器。用户可以实现方法来决定何时以及是否中止通信器并重新启动 NCCL "
"操作。以下是一个示例，展示了如何以非阻塞方式初始化和分割通信器，允许在任何时刻中止："

#: ../../source/usage/communicators.rst:357 d7141a1dd80d4ffe930c63a944684b19
msgid ""
"*checkTimeout* function is just an example and provided by users to determine what is the longest time the application "
"should wait for NCCL initialization; likewise, users can apply other methods to detect errors besides timeout function. "
"Similar methods can be applied to NCCL finalization as well."
msgstr "*checkTimeout* 函数只是一个示例，由用户提供，用于确定应用程序等待 NCCL 初始化的最长时间；同样，用户可以应用其他方法来检测错误，而不仅仅是超时函数。类似的方法也可以应用于 NCCL 结束。"
