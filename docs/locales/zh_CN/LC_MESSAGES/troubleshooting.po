# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the NCCL(2.19) package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: NCCL(2.19)\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-27 11:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: gpt-po v1.0.11\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../source/troubleshooting.rst:3 bad445538d91403ea3125eac48397844
msgid "Troubleshooting"
msgstr "故障排除"

#: ../../source/troubleshooting.rst:5 af9c170a1fb54dda9f6ef902ce240617
msgid "Ensure you are familiar with the following known issues and useful debugging strategies."
msgstr "确保您熟悉以下已知问题和有用的调试策略。"

#: ../../source/troubleshooting.rst:9 3bcc8379f5a04e4e81a007d1777d6a5c
msgid "Errors"
msgstr "错误"

#: ../../source/troubleshooting.rst:11 0fc144a697fd470fa3fb8eac1320b2ea
msgid ""
"NCCL calls may return a variety of return codes. Ensure that the return codes are always equal to ncclSuccess. If any "
"call fails and returns a value different from ncclSuccess, setting NCCL_DEBUG to \"WARN\" will make NCCL print an "
"explicit warning message before returning the error."
msgstr ""
"NCCL 调用可能会返回各种返回代码。确保返回代码始终等于 ncclSuccess。如果任何调用失败并返回与 ncclSuccess 不同的值，则将 NCCL_DEBUG 设置为 \"WARN\" 将使 NCCL "
"在返回错误之前打印明确的警告消息。"

#: ../../source/troubleshooting.rst:13 69476c645ca34945a7c7264d16578228
msgid "Errors are grouped into different categories."
msgstr "错误被分成不同的类别。"

#: ../../source/troubleshooting.rst:15 7c041493411449a5936874325c95db0b
msgid "ncclUnhandledCudaError and ncclSystemError indicate that a call to an external library failed."
msgstr "`ncclUnhandledCudaError`和`ncclSystemError`表示调用外部库时出现错误。"

#: ../../source/troubleshooting.rst:16 6da67c6f0b854c42b553b4dbe8a5b0bc
msgid "ncclInvalidArgument and ncclInvalidUsage indicates there was a programming error in the application using NCCL."
msgstr "`ncclInvalidArgument`和`ncclInvalidUsage`表示在使用NCCL的应用程序中存在编程错误。"

#: ../../source/troubleshooting.rst:18 ee33b156d8174755b8add71f95b94675
msgid "In either case, refer to the NCCL warning message to understand how to resolve the problem."
msgstr "无论哪种情况，请参考 NCCL 警告消息以了解如何解决问题。"

#: ../../source/troubleshooting.rst:22 d55124167d534134bbcc695561d9813e
msgid "GPU Direct"
msgstr "GPU直通"

#: ../../source/troubleshooting.rst:24 1db83ad5e84f4ffb861f915919b0b804
msgid ""
"NCCL heavily relies on GPU Direct for inter-GPU communication. This refers to the ability for a GPU to directly "
"communicate with another device, such as another GPU or a network card, using direct point-to-point PCI messages."
msgstr "NCCL 在 GPU 之间的通信中严重依赖 GPU Direct。这指的是 GPU 直接与另一个设备通信的能力，比如另一个 GPU 或网络卡，使用直接点对点的 PCI 消息。"

#: ../../source/troubleshooting.rst:27 9d77a9cd8f694e839b76be7ce38e0606
msgid ""
"Direct point-to-point PCI messages can fail or perform poorly for a variety of reasons, like missing components, a bad "
"configuration of a virtual machine or a container, or some BIOS settings."
msgstr "直接点对点的PCI消息可能因各种原因而失败或性能不佳，比如缺少组件、虚拟机或容器的错误配置，或一些BIOS设置。"

#: ../../source/troubleshooting.rst:31 21a4445261c446f89186b0b817c76e83
msgid "GPU-to-GPU communication"
msgstr "GPU 到 GPU 的通信"

#: ../../source/troubleshooting.rst:33 d0598fb8bd994bf1a49b5aa0c907f309
msgid "To make sure GPU-to-GPU communication is working correctly, look for the p2pBandwidthLatencyTest from the CUDA samples."
msgstr "为了确保 GPU 之间的通信正常工作，请查找 CUDA 示例中的 p2pBandwidthLatencyTest。"

#: ../../source/troubleshooting.rst:42 bca4ba016b1940338f39e015f9cf7df8
msgid "The test should run to completion and report good performance between GPUs."
msgstr "测试应该运行到完成并报告GPU之间的良好性能。"

#: ../../source/troubleshooting.rst:44 8ebe5edab59f45388349710fcba82ea1
msgid ""
"Another tool for checking GPU-to-GPU performance is called ``nvbandwidth``. This can be downloaded and built from the "
"code and instructions found here: https://github.com/NVIDIA/nvbandwidth"
msgstr "另一个用于检查 GPU 到 GPU 性能的工具称为 ``nvbandwidth``。可以从以下链接找到代码和说明，下载并构建该工具：https://github.com/NVIDIA/nvbandwidth"

#: ../../source/troubleshooting.rst:48 97411b0a81014d18adeb0132fb2d40e5
msgid "GPU-to-NIC communication"
msgstr "GPU-to-NIC通信"

#: ../../source/troubleshooting.rst:50 2f04438d04164febb9a1a1e375de1e89
msgid ""
"GPUs can also communicate directly with network cards using GPU Direct RDMA. This requires having a compatible network "
"cards and drivers, plus loading an extra kernel module called ``nvidia-peermem``. The ``nvidia-peermem`` module is now "
"supplied with the CUDA drivers, however it must be loaded on each node boot with:"
msgstr ""
"GPU也可以使用GPU Direct "
"RDMA直接与网络卡通信。这需要具有兼容的网络卡和驱动程序，以及加载一个名为``nvidia-peermem``的额外内核模块。``nvidia-peermem``模块现在随CUDA驱动程序一起提供，但必须在每个节点启动时加载："

#: ../../source/troubleshooting.rst:60 ec8974be9afd48229ccf65757ff817d0
msgid "PCI Access Control Services (ACS)"
msgstr "PCI访问控制服务（ACS）"

#: ../../source/troubleshooting.rst:62 47081acde25149309692d74533d26579
msgid ""
"IO virtualization (also known as, VT-d or IOMMU) can interfere with GPU Direct by redirecting all PCI point-to-point "
"traffic to the CPU root complex, causing a significant performance reduction or even a hang. You can check whether ACS "
"is enabled on PCI bridges by running:"
msgstr "IO虚拟化（也称为VT-d或IOMMU）可能会通过将所有PCI点对点流量重定向到CPU根复杂来干扰GPU直通，导致显着的性能降低甚至挂起。您可以通过运行以下命令来检查PCI桥上是否启用了ACS："

#: ../../source/troubleshooting.rst:70 2b848059c2034f3f9b7b94a53d2d36b7
msgid ""
"If lines show \"SrcValid+\", then ACS might be enabled. Looking at the full output of lspci, one can check if a PCI "
"bridge has ACS enabled."
msgstr "如果行中显示\"SrcValid+\"，那么ACS可能已启用。查看lspci的完整输出，可以检查PCI桥是否已启用ACS。"

#: ../../source/troubleshooting.rst:77 1808e21ae448471db0ad4e902cad2188
msgid ""
"If PCI switches have ACS enabled, it needs to be disabled. On some systems this can be done from the BIOS by disabling "
"IO virtualization or VT-d. For Broadcom PLX devices, it can be done from the OS but needs to be done again after each "
"reboot."
msgstr "如果 PCI 开关启用了 ACS，需要将其禁用。在某些系统上，可以通过在 BIOS 中禁用 IO 虚拟化或 VT-d 来完成此操作。对于 Broadcom PLX 设备，可以在操作系统中完成此操作，但需要在每次重新启动后再次执行。"

#: ../../source/troubleshooting.rst:81 70d3434f5b5440ab803dc89119c80ad8
msgid "Use the command below to find the PCI bus IDs of PLX PCI bridges:"
msgstr "使用以下命令查找 PLX PCI 桥接器的 PCI 总线 ID："

#: ../../source/troubleshooting.rst:87 6d881d174cea4e93b8ff0dfa012f438c
msgid "Next, use setpci to disable ACS with the command below, replacing 03:00.0 by the PCI bus ID of each PCI bridge."
msgstr "接下来，请使用以下命令中的setpci来禁用ACS，将03:00.0替换为每个PCI桥梁的PCI总线ID。"

#: ../../source/troubleshooting.rst:95 8fcec330b40c446a986ebf5260025826
msgid "Topology detection"
msgstr "拓扑检测"

#: ../../source/troubleshooting.rst:97 8efff10aacad4e34a9e631e2e1d79f1d
msgid ""
"NCCL relies on /sys to discover the PCI topology of GPUs and network cards. When running inside a virtual machine or "
"container, make sure /sys is properly mounted. Having /sys expose a virtual PCI topology can result in sub-optimal "
"performance."
msgstr "NCCL 依赖 /sys 来发现 GPU 和网络卡的 PCI 拓扑结构。在虚拟机或容器中运行时，请确保 /sys 被正确挂载。让 /sys 暴露虚拟 PCI 拓扑结构可能导致性能不佳。"

#: ../../source/troubleshooting.rst:103 18f0b3b7c75c4a79a1df7c6b061bcf98
msgid "Shared memory"
msgstr "共享内存"

#: ../../source/troubleshooting.rst:105 7545b36457834c17ac6a2d3f79b34d10
msgid ""
"To communicate between processes and even between threads of a process, NCCL creates shared memory segments in "
"/dev/shm. The operating system's limits on these resources may need to be increased accordingly. Please see your "
"system's documentation for details."
msgstr "为了在进程之间甚至在进程的不同线程之间进行通信，NCCL 在 /dev/shm 中创建共享内存段。操作系统对这些资源的限制可能需要相应地增加。请查阅您系统的文档以获取详细信息。"

#: ../../source/troubleshooting.rst:109 6a89aaafa3744ee29fbbf0b72b66a588
msgid ""
"If insufficient shared memory is available, NCCL will fail to initialize. Running with NCCL_DEBUG=WARN will show a "
"message similar to this:"
msgstr "如果可用的共享内存不足，NCCL 将无法初始化。使用 NCCL_DEBUG=WARN 运行将显示类似于以下消息："

#: ../../source/troubleshooting.rst:117 bc742d7c817b4ace8f156c746689942c
msgid "Docker"
msgstr "Docker"

#: ../../source/troubleshooting.rst:119 c896369f2be44f15918b6a6c680915e7
msgid ""
"In particular, Docker containers default to limited shared and pinned memory resources. When using NCCL inside a "
"container, please make sure to adjust the shared memory size inside the container, for example by adding the following "
"arguments to the docker launch command line:"
msgstr "具体来说，Docker 容器默认使用有限的共享和固定内存资源。在容器内使用 NCCL 时，请确保调整容器内的共享内存大小，例如通过将以下参数添加到 Docker 启动命令行中："

#: ../../source/troubleshooting.rst:128 a8988d15749f43e6a425d728418cb853
msgid "Systemd"
msgstr "Systemd"

#: ../../source/troubleshooting.rst:130 1989c94fa32b4dcb82d6e870a94d6f73
msgid ""
"When running jobs using mpirun or SLURM, systemd may remove files in shared memory when it detects that the "
"corresponding user is not logged in, in an attempt to clean up old temporary files. This can cause NCCL to crash during "
"init with an error like:"
msgstr "在使用 mpirun 或 SLURM 运行作业时，systemd 可能会在检测到相应用户未登录时删除共享内存中的文件，以清理旧的临时文件。这可能会导致 NCCL 在初始化期间崩溃，并显示类似以下错误："

#: ../../source/troubleshooting.rst:138 684515e111634ab7ab72ba219c1650a6
msgid ""
"Given mpirun and SLURM jobs can run on the node without the user being seen as logged in by systemd, system "
"administrators need to disable that clean-up mechanism, which can be performed by SLURM epilogue scripts instead. To do "
"this, the following line needs to be set in /etc/systemd/logind.conf:"
msgstr ""
"由于 mpirun 和 SLURM 作业可以在节点上运行，而用户不会被 systemd 视为已登录，因此系统管理员需要禁用清理机制，可以通过 SLURM epilogue 脚本来执行。要实现这一点，需要在 "
"/etc/systemd/logind.conf 中设置以下行："

#: ../../source/troubleshooting.rst:146 ca81561796f846bf95f2fe06bf0ef654
msgid "Once updated, the daemons should be restarted with:"
msgstr "更新完成后，应使用以下命令重新启动守护程序："

#: ../../source/troubleshooting.rst:154 d28b3877d03c4dc99122ccdf84522f6b
msgid "Networking issues"
msgstr "网络问题"

#: ../../source/troubleshooting.rst:157 3799a7fd612a415a95d6bca892228464
msgid "IP Network Interfaces"
msgstr "IP 网络接口"

#: ../../source/troubleshooting.rst:159 414be91a73c945f597fc91d4bb775699
msgid ""
"NCCL auto-detects which network interfaces to use for inter-node communication. If some interfaces are in state up, "
"however are not able to communicate between nodes, NCCL may try to use them anyway and therefore fail during the init "
"functions or even hang."
msgstr "NCCL 会自动检测用于节点间通信的网络接口。如果某些接口处于启用状态，但节点之间无法通信，NCCL 可能会尝试使用它们，因此在初始化函数期间甚至会出现失败或挂起。"

#: ../../source/troubleshooting.rst:161 3742a8f29cb04ba8bbdd9aaa2d92b5fc
msgid ""
"For information about how to specify which interfaces to use, see NCCL Knobs section, particularly the "
"NCCL_SOCKET_IFNAME knob."
msgstr "有关如何指定要使用的接口的信息，请参阅NCCL旋钮部分，特别是NCCL_SOCKET_IFNAME旋钮。"

#: ../../source/troubleshooting.rst:164 801800ca137c47ca959d059fecf795bb
msgid "IP Ports"
msgstr "IP端口"

#: ../../source/troubleshooting.rst:166 2987d8a78ae84b1d92e1d7eeed5ab812
msgid ""
"NCCL opens TCP ports to connect processes together and exchange connection information. To restrict the range of ports "
"used by NCCL, one can set the net.ipv4.ip_local_port_range property of the Linux kernel."
msgstr "NCCL打开TCP端口以连接进程并交换连接信息。要限制NCCL使用的端口范围，可以设置Linux内核的net.ipv4.ip_local_port_range属性。"

#: ../../source/troubleshooting.rst:169 9f66a93022c04c8a8274499e67b1b19d
msgid "This example shows how to restrict NCCL ports to 50000-51000:"
msgstr "此示例显示如何将 NCCL 端口限制在 50000-51000 范围内："

#: ../../source/troubleshooting.rst:175 3293962420e6405383fdd95c0aade7fe
msgid "Or to make this permanent, add a line to /set/sysctl.conf:"
msgstr "或者要使此更改永久生效，请在 `/set/sysctl.conf` 中添加一行："

#: ../../source/troubleshooting.rst:181 07b69026478142aa99441569bb4dbd30
msgid "Restricting the port range can be useful to open a corresponding range in the firewall, for example on Google Cloud:"
msgstr "限制端口范围可以帮助在防火墙中打开相应的范围，例如在Google Cloud中："

#: ../../source/troubleshooting.rst:188 22ad102e660b4b15acd52b7244b5c339
msgid "InfiniBand"
msgstr "InfiniBand"

#: ../../source/troubleshooting.rst:190 7703c3d65f844278b938bd075788630c
msgid ""
"Before running NCCL on InfiniBand, running low-level InfiniBand tests (and in particular the ib_write_bw test) can help "
"verify which nodes are able to communicate properly."
msgstr "在在 InfiniBand 上运行 NCCL 之前，运行低级别的 InfiniBand 测试（特别是 ib_write_bw 测试）可以帮助验证哪些节点能够正确通信。"

#: ../../source/troubleshooting.rst:192 ae9bdccfaf514c52a733af091be7843a
msgid ""
"A common issue seen with InfiniBand is the library not being able to register sufficient pinned memory. In such cases "
"you may see an error like:"
msgstr "InfiniBand 经常出现的问题是库无法注册足够的固定内存。在这种情况下，您可能会看到以下错误："

#: ../../source/troubleshooting.rst:198 58a604fc421d44c88dd1022c98be1891
msgid "or"
msgstr "或"

#: ../../source/troubleshooting.rst:204 5723c34337f94e098976128cd24b213e
msgid "The solution is to remove the user limits on registering pinned memory. This can be done by adding these lines:"
msgstr "解决方案是取消注册固定内存的用户限制。可以通过添加以下行来实现："

#: ../../source/troubleshooting.rst:211 99bc2f79c15f4b379b9f2219d5db5442
msgid "To the /etc/security/limits.conf configuration file or equivalent on your Linux distribution."
msgstr "将此配置添加到您的Linux发行版上的/etc/security/limits.conf文件或等效文件中。"
